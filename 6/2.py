from memory_profiler import profile
from pympler import asizeof

"""
Система: Windows 10 (x86)
Язык: Python 3.8.6 (tags/v3.8.6:db45529, Sep 23 2020, 15:37:30) [MSC v.1927 32 bit (Intel)] on win32
Среда разработки: VSCode
    Версия: 1.52.1 (user setup)
    Фиксация: ea3859d4ba2f3e577a159bc91e3074c5d85c0523
    Дата: 2020-12-16T16:34:50.160Z
    Electron: 9.3.5
    Chrome: 83.0.4103.122
    Node.js: 12.14.1
    V8: 8.3.110.13-electron.0
    ОС: Windows_NT ia32 10.0.19041
"""

"""
Для контроля за состоянием памяти можно использовать модули memory_profiler и pympler.
Memory_profiler:
    Плюсы:
        Декоратор, который позволяет быстро и просто получить минимально необходимый объем информации о потреблении памяти в исполняемой программе
    Минусы:
        Зачастую, даже после многочисленных тестов и выявления места 'утечки' памяти, memory_profiler не позволит определить, на что именно уходит память.
"""
@profile
def memory_profiler_example():
    test_0 = "tstetst"
    test_1 = 12343214324

"""
Pympler:
    Плюсы:
        Позволяет получить детальную информацию потребления памяти
    Минусы:
        Чуть более сложен в освоении
"""
def pympler_example():
    test_1 = [i for i in range(200)]
    test_2 = range(5)

    print(f"Размер test_1: {asizeof.asizeof(test_1)}")
    print(f"Размер test_2: {asizeof.asizeof(test_2)}")

"""
Вышеуказанные инструменты позволяет разработчику определить 'слабые места' в написанном коде.

Общие советы по написанию кода, которое может сократить потребление памяти:
    1.Пропускать неиспользуемые куски кода
        Например, довольно часто при работе с файлами встречаются определенное число закомментированных строк, которые при стандартном исполнении в той или иной степени нагружают память.
        В таком случае необходимо на этапе получения переменной отфильтровать входные данные, чтобы пропустить все строки, начинающиеся с определенных символом, например, с '//'
"""
@profile
def filter_example():
    test = """"
// lalala
//;a;a;a;a;adflkf
//asldfkjlkfj

Hello, World!
    """
    t = [i for i in test.split("\n") if "//" not in i]

    for line in t:
        print(line)
"""
    2.Использовать запись типа __slots__ = "..." внутри классов с многочисленными переменными
        Если для использования программы необходимо использовать классы с указанием 'тяжелых' переменных, можно использовать __slots__, чтобы python использовал нестандартный (словарный) метод записи переменных внутри класса с динамическим выделением памяти, а выделил фиксированную величину под указанные параметры.
        Важное замечание:
            При использовании данного метода объвление новых переменных внутри класса Возможно Только Внутри __slots__!
"""

@profile
class Slots_example():
    __slots__ = ["test_1", "test_2"]

    def __init__(self, test1, test2):
        self.test_1 = test1
        self.test_2 = test2

    def __str__(self):
        return self.test_1
"""
    3.Использование kwargs при инициализации скрипта вместо запроса ввода в ходе исполнения
        Если для корректного исполнения программы необходимо многочисленное повторние однотипных действий, уместно (помимо использования классов/функций) при вызове необходимых действий передавать заранее поименованные переменные вместо 'безымянных'.
        В таком случае python не позволит создать дублирующиеся переменные, а потребует от пользователя указать строго неоходимые, что может, во-первых, улучшить читаемость кода, во-вторых, уменьшит потребление ресурсов ПК
"""

@profile
def kwargs_example(*, test_1, test_2):
    print(test_1, test_2)

kwargs_example(test_1="test1", test_2="test2")
# kwargs_example("test1", "test2")
memory_profiler_example()
pympler_example()
filter_example()
print(Slots_example("test1", "test2"))
